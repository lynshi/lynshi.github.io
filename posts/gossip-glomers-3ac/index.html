<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Gossip Glomers 3 (a-c): Single-Node, Multi-Node, and Fault Tolerant Broadcast | Nibbles and Bytes</title><meta name=keywords content="Distributed systems,fly.io,Gossip Glomers"><meta name=description content="It gets more involved at 3d, so let's talk about a-c first."><meta name=author content="Lyndon Shi"><link rel=canonical href=https://lynshi.github.io/posts/gossip-glomers-3ac/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://lynshi.github.io/favicon/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://lynshi.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lynshi.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://lynshi.github.io/favicon/apple-touch-icon.png><link rel=mask-icon href=https://lynshi.github.io/favicon/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})'></script><meta property="og:title" content="Gossip Glomers 3 (a-c): Single-Node, Multi-Node, and Fault Tolerant Broadcast"><meta property="og:description" content="It gets more involved at 3d, so let's talk about a-c first."><meta property="og:type" content="article"><meta property="og:url" content="https://lynshi.github.io/posts/gossip-glomers-3ac/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-29T14:57:01-08:00"><meta property="article:modified_time" content="2023-11-29T14:57:01-08:00"><meta property="og:site_name" content="Nibbles and Bytes"><meta name=twitter:card content="summary"><meta name=twitter:title content="Gossip Glomers 3 (a-c): Single-Node, Multi-Node, and Fault Tolerant Broadcast"><meta name=twitter:description content="It gets more involved at 3d, so let's talk about a-c first."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lynshi.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Gossip Glomers 3 (a-c): Single-Node, Multi-Node, and Fault Tolerant Broadcast","item":"https://lynshi.github.io/posts/gossip-glomers-3ac/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Gossip Glomers 3 (a-c): Single-Node, Multi-Node, and Fault Tolerant Broadcast","name":"Gossip Glomers 3 (a-c): Single-Node, Multi-Node, and Fault Tolerant Broadcast","description":"It gets more involved at 3d, so let's talk about a-c first.","keywords":["Distributed systems","fly.io","Gossip Glomers"],"articleBody":"Last time we introduced the Gossip Glomers challenge from Fly.io and discussed our approach to Challenge #2: Unique ID Generation.\nThis time, we’ll talk about the first three parts of Challenge #3: Broadcast. Parts D and E are saved for a separate post as they’re a bit more involved.\nThe overall theme of Challenge 3 is to build a broacast system to propagate messages to all nodes1. We iteratively build up our system, from a single-node cluster that simply stores and returns received messages, to a multi-node cluster that shares received messages, to a fault-tolerant multi-node cluster that can operate even during network partitions by Part C (D and E are about efficiency).\nAs before, my code is on GitHub at lynshi/gossip-glomers under internal/broadcast.\n3a: Single-Node Broadcast We start off implementing only one node to ensure that we receive and save broadcasted messages correctly. There are three types of messages our node needs to handle:\nbroadcast: Store the value received. read: Return all values received by the node. topology: Receive information about neighbors. To store values, we’ll use an array of integers. Since we may have multiple handlers running concurrently, we’ll use a channel to synchronize access. This channel will have a buffer size of 1 and we’ll initialize it with an empty integer array. To add to the array, the broadcast handler will read the array to consume the single copy, append to it, and write it back to the channel. Similarly, the read handler will read the array from the channel and return a copy in the response.\nIn order to make it easy to have a distinct implementation for each part, we’ll wrap the data structures used in a struct. For example, for Part A we’ll define SingleNodeNode.\ntype SingleNodeNode struct { mn *maelstrom.Node messages chan []int } func NewSingleNodeNode(ctx context.Context, n *maelstrom.Node) { messages = make(chan []int, 1) messages \u003c- make([]int, 0, 1) n := SingleNodeNode{ mn: mn, messages: messages, } go func() { \u003c-ctx.Done() close(messages) }() n.addBroadcastHandle() n.addReadHandle() n.addTopologyHandle() return \u0026n } func (n *SingleNodeNode) broadcastSingleNodeBuilder() maelstrom.HandlerFunc { broadcast := func(req maelstrom.Message) error { // ... message, _ := getMessage(body) msgs := \u003c-n.messages msgs = append(msgs, int(message)) n.messages \u003c- msgs // ... } return broadcast } func (n *SingleNodeNode) readBuilder() maelstrom.HandlerFunc { read := func(req maelstrom.Message) error { msgs := \u003c-n.messages // Now that we have a local copy, we can immediately return it to the channel so that other // goroutines are unblocked. n.messages \u003c- msgs resp := make(map[string]any) resp[\"type\"] = \"read_ok\" resp[\"messages\"] = msgs return n.mn.Reply(req, resp) } return read } My code for Part A is at internal/broadcast/3a.go.\nA note on topology The topology message type is odd. The problem statement says that we can ignore the provided neighbors and build our own topology from Maelstrom’s list of all nodes, as all nodes can communicate with each other. At first, I was confused about this as there doesn’t seem to be a point of this message then, and based on a glance at community.fly.io I wasn’t the only one2. However, someone explained that “the topology is just a way to logically arrange nodes” and that Maelstrom allows you to select a topology, so my conclusion is that the topology can be interpreted as a recommendation for inter-node communication3 and also provides consistency with Maelstrom’s problem formulation, which causes the Maelstrom controller to send a topology message when starting up the nodes. Ultimately, I chose to ignore this message for all sections of this challenge as I constructed my own topology later on.\n3b: Multi-Node Broadcast In Part B, we introduce multiple nodes, and upon receiving a broadcast message a node must distribute that message to all other nodes within a few seconds. Because all messages are unique, I decided to store the messages in a map[int]interface{} instead so that saved messages are automatically deduplicated 4. Similarly to previous section, we initialize a MultiNodeNode by adding an empty map to the messages channel.\ntype MultiNodeNode struct { mn *maelstrom.Node messages chan map[int]interface{} } func NewMultiNodeNode(ctx context.Context, mn *maelstrom.Node) *MultiNodeNode { messages := make(chan map[int]interface{}, 1) messages \u003c- make(map[int]interface{}) n := \u0026MultiNodeNode{ mn: mn, messages: messages, } // ... return \u0026n } Since we have to forward messages received from the controller to other nodes as soon as possible, upon receipt of a broadcast message that did not originate from another node, the node initiates a goroutine to send the message to every other node. We use the Maelstrom-provided method Send, which is a fire-and-forget method that sends a message to the specified destination, as there aren’t network failures in this scenario.\nbroadcast := func(req maelstrom.Message) error { // ... // Only forward if the message did not come from another node. if strings.HasPrefix(req.Src, \"n\") { return nil } go func() { for _, neighbor := range n.mn.NodeIDs() { req := make(map[string]any) req[\"type\"] = \"broadcast\" req[\"message\"] = message go n.mn.Send(neighbor, req) } }() resp := make(map[string]any) resp[\"type\"] = \"broadcast_ok\" return n.mn.Reply(req, resp) } The read handler is very similar to before, except we now must convert the map into an array.\nread := func(req maelstrom.Message) error { messages := \u003c-n.messages n.messages \u003c- messages resp := make(map[string]any) resp[\"type\"] = \"read_ok\" resp_messages := make([]int, 0, len(messages)) for v, _ := range messages { resp_messages = append(resp_messages, v) } resp[\"messages\"] = resp_messages return n.mn.Reply(req, resp) } The full code for Part B is at internal/broadcast/3b.go.\n3c: Fault Tolerant Broadcast Part C introduces network partitions to temporarily prevent inter-node communication. To accommodate, we use RPC instead of Send, as RPC checks for a successful response. RPC takes a callback handler, which we use to set a local success variable to true to prevent further retries5. Otherwise, the network call is retried.\nTo reduce latency, we’ll have every node forward received broadcast messages even if they weren’t the first node to get it. This means we can detour around partitions when possible at the cost of message duplication. Of course, if a node finds that it has already received the message, we skip forwarding as it must have already done so earlier; this avoids infinite forwarding cycles. This resulted in tiny latencies (milliseconds): :stable-latencies {0 0, 0.5 0, 0.95 0, 0.99 3, 1 3}. Without this optimization — that is, if only the first node forwards — the latency was :stable-latencies {0 0, 0.5 1022, 0.95 10504, 0.99 11563, 1 12205}.\nfunc (n *FaultTolerantNode) forward_to_all(message int) { for _, neighbor := range n.mn.NodeIDs() { if neighbor == n.mn.ID() { continue } req := make(map[string]any) req[\"type\"] = \"broadcast\" req[\"message\"] = message go n.forward(neighbor, req) } } func (n *FaultTolerantNode) forward(neighbor string, body map[string]any) { for { success := false err := n.mn.RPC(neighbor, body, func(resp maelstrom.Message) error { success = true return nil }) if err == nil \u0026\u0026 success { return } // Let's not bother with fancy backoffs since we know the partition // heals eventually. time.Sleep(500 * time.Millisecond) } } broadcast := func(req maelstrom.Message) error { // ... messages := \u003c-n.messages _, val_exists := messages[message] messages[message] = nil n.messages \u003c- messages if !val_exists { go n.forward_to_all(message) } // ... } For the complete implementation of Part C, see internal/broadcast/3c.go.\nNote that nodes never crash so we don’t have to worry about persisting data to disk. ↩︎\nmaelstrom challenge: request to implement topology and then ignore it is very confusing. ↩︎\nThis is relevant for later challenges, where efficiency requirements mean you can’t have a node talk to every other node. ↩︎\nGo doesn’t have sets, so a map[int]interface{} is a workaround for creating a set of integers as the value in each key-value pair is ignored and usually set to nil. ↩︎\nI didn’t look at the documentation, but from brief experimentation I hypothesize that Send and RPC only return errors if there was an issue sending the message (which is probably rare). However, Send doesn’t guarantee receipt, while RPC will call the callback handler once the message is received, even if the recipient node doesn’t actually reply with anything. ↩︎\n","wordCount":"1328","inLanguage":"en","datePublished":"2023-11-29T14:57:01-08:00","dateModified":"2023-11-29T14:57:01-08:00","author":{"@type":"Person","name":"Lyndon Shi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lynshi.github.io/posts/gossip-glomers-3ac/"},"publisher":{"@type":"Organization","name":"Nibbles and Bytes","logo":{"@type":"ImageObject","url":"https://lynshi.github.io/favicon/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lynshi.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://lynshi.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lynshi.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://lynshi.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://lynshi.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lynshi.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://lynshi.github.io/posts/>Posts</a></div><h1 class=post-title>Gossip Glomers 3 (a-c): Single-Node, Multi-Node, and Fault Tolerant Broadcast</h1><div class=post-description>It gets more involved at 3d, so let's talk about a-c first.</div><div class=post-meta><span title='2023-11-29 14:57:01 -0800 -0800'>November 29, 2023</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1328 words&nbsp;·&nbsp;Lyndon Shi&nbsp;|&nbsp;<a href=https://github.com/lynshi/blog/tree/main/content/posts/gossip-glomers-3ac.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p><a href=https://lynshi.github.io/posts/gossip-glomers-intro-and-unique-id-generation/>Last time</a> we introduced the Gossip Glomers challenge from <a href=https://fly.io/>Fly.io</a> and discussed our approach to <a href=https://fly.io/dist-sys/2/>Challenge #2: Unique ID Generation</a>.</p><p>This time, we&rsquo;ll talk about the first three parts of <a href=https://fly.io/dist-sys/3a/>Challenge #3: Broadcast</a>. Parts D and E are saved for a separate post as they&rsquo;re a bit more involved.</p><p>The overall theme of Challenge 3 is to build a broacast system to propagate messages to all nodes<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. We iteratively build up our system, from a single-node cluster that simply stores and returns received messages, to a multi-node cluster that shares received messages, to a fault-tolerant multi-node cluster that can operate even during network partitions by Part C (D and E are about efficiency).</p><p>As before, my code is on GitHub at <a href=https://github.com/lynshi/gossip-glomers><code>lynshi/gossip-glomers</code></a> under <a href=https://github.com/lynshi/gossip-glomers/tree/main/internal/broadcast><code>internal/broadcast</code></a>.</p><hr><h1 id=3a-single-node-broadcast>3a: Single-Node Broadcast<a hidden class=anchor aria-hidden=true href=#3a-single-node-broadcast>#</a></h1><p>We start off implementing only one node to ensure that we receive and save broadcasted messages correctly. There are three types of messages our node needs to handle:</p><ul><li><code>broadcast</code>: Store the value received.</li><li><code>read</code>: Return all values received by the node.</li><li><code>topology</code>: Receive information about neighbors.</li></ul><p>To store values, we&rsquo;ll use an array of integers. Since we may have multiple handlers running concurrently, we&rsquo;ll use a channel to synchronize access. This channel will have a buffer size of 1 and we&rsquo;ll initialize it with an empty integer array. To add to the array, the <code>broadcast</code> handler will read the array to consume the single copy, append to it, and write it back to the channel. Similarly, the <code>read</code> handler will read the array from the channel and return a copy in the response.</p><p>In order to make it easy to have a distinct implementation for each part, we&rsquo;ll wrap the data structures used in a struct. For example, for Part A we&rsquo;ll define <code>SingleNodeNode</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>SingleNodeNode</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>mn</span> <span class=o>*</span><span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>messages</span> <span class=kd>chan</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewSingleNodeNode</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>n</span> <span class=o>*</span><span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>messages</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>messages</span> <span class=o>&lt;-</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>n</span> <span class=o>:=</span> <span class=nx>SingleNodeNode</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>mn</span><span class=p>:</span>       <span class=nx>mn</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>messages</span><span class=p>:</span> <span class=nx>messages</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;-</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nb>close</span><span class=p>(</span><span class=nx>messages</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>n</span><span class=p>.</span><span class=nf>addBroadcastHandle</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=nx>n</span><span class=p>.</span><span class=nf>addReadHandle</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=nx>n</span><span class=p>.</span><span class=nf>addTopologyHandle</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>&amp;</span><span class=nx>n</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>n</span> <span class=o>*</span><span class=nx>SingleNodeNode</span><span class=p>)</span> <span class=nf>broadcastSingleNodeBuilder</span><span class=p>()</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nx>HandlerFunc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>broadcast</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>req</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Message</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nx>message</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nf>getMessage</span><span class=p>(</span><span class=nx>body</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>msgs</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>n</span><span class=p>.</span><span class=nx>messages</span>
</span></span><span class=line><span class=cl>    <span class=nx>msgs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>msgs</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=nx>message</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span><span class=p>.</span><span class=nx>messages</span> <span class=o>&lt;-</span> <span class=nx>msgs</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>broadcast</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>n</span> <span class=o>*</span><span class=nx>SingleNodeNode</span><span class=p>)</span> <span class=nf>readBuilder</span><span class=p>()</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nx>HandlerFunc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>read</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>req</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Message</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>msgs</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>n</span><span class=p>.</span><span class=nx>messages</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Now that we have a local copy, we can immediately return it to the channel so that other
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// goroutines are unblocked.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>n</span><span class=p>.</span><span class=nx>messages</span> <span class=o>&lt;-</span> <span class=nx>msgs</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>resp</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>resp</span><span class=p>[</span><span class=s>&#34;type&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;read_ok&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>resp</span><span class=p>[</span><span class=s>&#34;messages&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=nx>msgs</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>n</span><span class=p>.</span><span class=nx>mn</span><span class=p>.</span><span class=nf>Reply</span><span class=p>(</span><span class=nx>req</span><span class=p>,</span> <span class=nx>resp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>read</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>My code for Part A is at <a href=https://github.com/lynshi/gossip-glomers/blob/main/internal/broadcast/3a.go><code>internal/broadcast/3a.go</code></a>.</p><h2 id=a-note-on-topology>A note on topology<a hidden class=anchor aria-hidden=true href=#a-note-on-topology>#</a></h2><p>The <code>topology</code> message type is odd. The problem statement says that we can ignore the provided neighbors and build our own topology from Maelstrom&rsquo;s list of all nodes, as all nodes can communicate with each other. At first, I was confused about this as there doesn&rsquo;t seem to be a point of this message then, and based on a glance at <a href=https://community.fly.io/tag/dist-sys-challenge>community.fly.io</a> I wasn&rsquo;t the only one<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. However, someone explained that <a href=https://community.fly.io/t/using-a-own-topology/11057/6>&ldquo;the topology is just a way to logically arrange nodes&rdquo; and that Maelstrom allows you to select a topology</a>, so my conclusion is that the topology can be interpreted as a recommendation for inter-node communication<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> and also provides consistency with Maelstrom&rsquo;s problem formulation, which causes the Maelstrom controller to send a <code>topology</code> message when starting up the nodes. Ultimately, I chose to ignore this message for all sections of this challenge as I constructed my own topology later on.</p><hr><h1 id=3b-multi-node-broadcast>3b: Multi-Node Broadcast<a hidden class=anchor aria-hidden=true href=#3b-multi-node-broadcast>#</a></h1><p>In <a href=https://fly.io/dist-sys/3b/>Part B</a>, we introduce multiple nodes, and upon receiving a <code>broadcast</code> message a node must distribute that message to all other nodes within a few seconds. Because all messages are unique, I decided to store the messages in a <code>map[int]interface{}</code> instead so that saved messages are automatically deduplicated <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>. Similarly to previous section, we initialize a <code>MultiNodeNode</code> by adding an empty map to the <code>messages</code> channel.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MultiNodeNode</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>mn</span> <span class=o>*</span><span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>messages</span> <span class=kd>chan</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewMultiNodeNode</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>mn</span> <span class=o>*</span><span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Node</span><span class=p>)</span> <span class=o>*</span><span class=nx>MultiNodeNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>messages</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kd>interface</span><span class=p>{},</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>messages</span> <span class=o>&lt;-</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kd>interface</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>n</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>MultiNodeNode</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>mn</span><span class=p>:</span>       <span class=nx>mn</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>messages</span><span class=p>:</span> <span class=nx>messages</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=o>&amp;</span><span class=nx>n</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Since we have to forward messages received from the controller to other nodes as soon as possible, upon receipt of a <code>broadcast</code> message that did not originate from another node, the node initiates a goroutine to send the message to every other node. We use the Maelstrom-provided method <code>Send</code>, which is a fire-and-forget method that sends a message to the specified destination, as there aren&rsquo;t network failures in this scenario.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>broadcast</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>req</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Message</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// Only forward if the message did not come from another node.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>HasPrefix</span><span class=p>(</span><span class=nx>req</span><span class=p>.</span><span class=nx>Src</span><span class=p>,</span> <span class=s>&#34;n&#34;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>neighbor</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>n</span><span class=p>.</span><span class=nx>mn</span><span class=p>.</span><span class=nf>NodeIDs</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>req</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nx>req</span><span class=p>[</span><span class=s>&#34;type&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;broadcast&#34;</span>
</span></span><span class=line><span class=cl>      <span class=nx>req</span><span class=p>[</span><span class=s>&#34;message&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=nx>message</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>go</span> <span class=nx>n</span><span class=p>.</span><span class=nx>mn</span><span class=p>.</span><span class=nf>Send</span><span class=p>(</span><span class=nx>neighbor</span><span class=p>,</span> <span class=nx>req</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>resp</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>resp</span><span class=p>[</span><span class=s>&#34;type&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;broadcast_ok&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>n</span><span class=p>.</span><span class=nx>mn</span><span class=p>.</span><span class=nf>Reply</span><span class=p>(</span><span class=nx>req</span><span class=p>,</span> <span class=nx>resp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The <code>read</code> handler is very similar to before, except we now must convert the map into an array.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>read</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>req</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Message</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>messages</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>n</span><span class=p>.</span><span class=nx>messages</span>
</span></span><span class=line><span class=cl>  <span class=nx>n</span><span class=p>.</span><span class=nx>messages</span> <span class=o>&lt;-</span> <span class=nx>messages</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>resp</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>resp</span><span class=p>[</span><span class=s>&#34;type&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;read_ok&#34;</span>
</span></span><span class=line><span class=cl>  <span class=nx>resp_messages</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>messages</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>v</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>messages</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>resp_messages</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>resp_messages</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>resp</span><span class=p>[</span><span class=s>&#34;messages&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=nx>resp_messages</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>n</span><span class=p>.</span><span class=nx>mn</span><span class=p>.</span><span class=nf>Reply</span><span class=p>(</span><span class=nx>req</span><span class=p>,</span> <span class=nx>resp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The full code for Part B is at <a href=https://github.com/lynshi/gossip-glomers/blob/main/internal/broadcast/3b.go><code>internal/broadcast/3b.go</code></a>.</p><hr><h1 id=3c-fault-tolerant-broadcast>3c: Fault Tolerant Broadcast<a hidden class=anchor aria-hidden=true href=#3c-fault-tolerant-broadcast>#</a></h1><p><a href=https://fly.io/dist-sys/3c/>Part C</a> introduces network partitions to temporarily prevent inter-node communication. To accommodate, we use <code>RPC</code> instead of <code>Send</code>, as <code>RPC</code> checks for a successful response. <code>RPC</code> takes a callback handler, which we use to set a local <code>success</code> variable to <code>true</code> to prevent further retries<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>. Otherwise, the network call is retried.</p><p>To reduce latency, we&rsquo;ll have every node forward received <code>broadcast</code> messages even if they weren&rsquo;t the first node to get it. This means we can detour around partitions when possible at the cost of message duplication. Of course, if a node finds that it has already received the message, we skip forwarding as it must have already done so earlier; this avoids infinite forwarding cycles. This resulted in tiny latencies (milliseconds): <code>:stable-latencies {0 0, 0.5 0, 0.95 0, 0.99 3, 1 3}</code>. Without this optimization — that is, if only the first node forwards — the latency was <code>:stable-latencies {0 0, 0.5 1022, 0.95 10504, 0.99 11563, 1 12205}</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>n</span> <span class=o>*</span><span class=nx>FaultTolerantNode</span><span class=p>)</span> <span class=nf>forward_to_all</span><span class=p>(</span><span class=nx>message</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>neighbor</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>n</span><span class=p>.</span><span class=nx>mn</span><span class=p>.</span><span class=nf>NodeIDs</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>neighbor</span> <span class=o>==</span> <span class=nx>n</span><span class=p>.</span><span class=nx>mn</span><span class=p>.</span><span class=nf>ID</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>continue</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>req</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>req</span><span class=p>[</span><span class=s>&#34;type&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;broadcast&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>req</span><span class=p>[</span><span class=s>&#34;message&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=nx>message</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nx>n</span><span class=p>.</span><span class=nf>forward</span><span class=p>(</span><span class=nx>neighbor</span><span class=p>,</span> <span class=nx>req</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>n</span> <span class=o>*</span><span class=nx>FaultTolerantNode</span><span class=p>)</span> <span class=nf>forward</span><span class=p>(</span><span class=nx>neighbor</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>body</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>success</span> <span class=o>:=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=nx>err</span> <span class=o>:=</span> <span class=nx>n</span><span class=p>.</span><span class=nx>mn</span><span class=p>.</span><span class=nf>RPC</span><span class=p>(</span><span class=nx>neighbor</span><span class=p>,</span> <span class=nx>body</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>resp</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Message</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>success</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>success</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Let&#39;s not bother with fancy backoffs since we know the partition
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// heals eventually.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>500</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>broadcast</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>req</span> <span class=nx>maelstrom</span><span class=p>.</span><span class=nx>Message</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=nx>messages</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>n</span><span class=p>.</span><span class=nx>messages</span>
</span></span><span class=line><span class=cl>  <span class=nx>_</span><span class=p>,</span> <span class=nx>val_exists</span> <span class=o>:=</span> <span class=nx>messages</span><span class=p>[</span><span class=nx>message</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=nx>messages</span><span class=p>[</span><span class=nx>message</span><span class=p>]</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>  <span class=nx>n</span><span class=p>.</span><span class=nx>messages</span> <span class=o>&lt;-</span> <span class=nx>messages</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>!</span><span class=nx>val_exists</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nx>n</span><span class=p>.</span><span class=nf>forward_to_all</span><span class=p>(</span><span class=nx>message</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>For the complete implementation of Part C, see <a href=https://github.com/lynshi/gossip-glomers/blob/main/internal/broadcast/3c.go><code>internal/broadcast/3c.go</code></a>.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Note that nodes never crash so we don&rsquo;t have to worry about persisting data to disk.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://community.fly.io/t/maelstrom-challenge-request-to-implement-topology-and-then-ignore-it-is-very-confusing/11337>maelstrom challenge: request to implement topology and then ignore it is very confusing.</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>This is relevant for later challenges, where efficiency requirements mean you can&rsquo;t have a node talk to every other node.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>Go doesn&rsquo;t have sets, so a <code>map[int]interface{}</code> is a workaround for creating a set of integers as the value in each key-value pair is ignored and usually set to <code>nil</code>.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>I didn&rsquo;t look at the documentation, but from brief experimentation I hypothesize that <code>Send</code> and <code>RPC</code> only return errors if there was an issue sending the message (which is probably rare). However, <code>Send</code> doesn&rsquo;t guarantee receipt, while <code>RPC</code> will call the callback handler once the message is received, even if the recipient node doesn&rsquo;t actually reply with anything.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://lynshi.github.io/tags/distributed-systems/>Distributed systems</a></li><li><a href=https://lynshi.github.io/tags/fly.io/>fly.io</a></li><li><a href=https://lynshi.github.io/tags/gossip-glomers/>Gossip Glomers</a></li></ul><nav class=paginav><a class=prev href=https://lynshi.github.io/posts/sortable_svelte_and_tauri/><span class=title>« Prev</span><br><span>Sortable + Svelte + Tauri: Getting a sortable list right in a cross-platform app</span></a>
<a class=next href=https://lynshi.github.io/posts/gossip-glomers-intro-and-unique-id-generation/><span class=title>Next »</span><br><span>Gossip Glomers: Intro and Unique ID Generation</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://lynshi.github.io/>Nibbles and Bytes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>