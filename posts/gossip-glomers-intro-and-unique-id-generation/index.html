<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Gossip Glomers: Intro and Unique ID Generation | Nibbles and Bytes</title><meta name=keywords content="Distributed systems,fly.io,Gossip Glomers"><meta name=description content="Who knew you could practice implementing distributed systems for fun?"><meta name=author content="Lyndon Shi"><link rel=canonical href=https://lynshi.github.io/posts/gossip-glomers-intro-and-unique-id-generation/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://lynshi.github.io/favicon/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://lynshi.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lynshi.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://lynshi.github.io/favicon/apple-touch-icon.png><link rel=mask-icon href=https://lynshi.github.io/favicon/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})'></script><meta property="og:title" content="Gossip Glomers: Intro and Unique ID Generation"><meta property="og:description" content="Who knew you could practice implementing distributed systems for fun?"><meta property="og:type" content="article"><meta property="og:url" content="https://lynshi.github.io/posts/gossip-glomers-intro-and-unique-id-generation/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-26T21:06:12-08:00"><meta property="article:modified_time" content="2023-11-26T21:06:12-08:00"><meta property="og:site_name" content="Nibbles and Bytes"><meta name=twitter:card content="summary"><meta name=twitter:title content="Gossip Glomers: Intro and Unique ID Generation"><meta name=twitter:description content="Who knew you could practice implementing distributed systems for fun?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lynshi.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Gossip Glomers: Intro and Unique ID Generation","item":"https://lynshi.github.io/posts/gossip-glomers-intro-and-unique-id-generation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Gossip Glomers: Intro and Unique ID Generation","name":"Gossip Glomers: Intro and Unique ID Generation","description":"Who knew you could practice implementing distributed systems for fun?","keywords":["Distributed systems","fly.io","Gossip Glomers"],"articleBody":"One of the challenges for practicing implementing distributed systems is that it is not easy to simulate the various situations a distributed system might find itself in. Moreover, I previously could not even come up with an easy way to deploy a toy setup; the only thing I could think of is to use minikube and build a Kubernetes-based environment, but frankly at that point it is too much investment for me1.\nFortunately, I recently came across a series of distributed systems challenges created by fly.io and Kyle Kingsbury (author of Jepsen): Gossip Glomers. The challenges use Maelstrom, a framework for running and testing toy implementations of distributed systems, so that you only have to implement the individual nodes and not worry about anything else. Even better, Maelstrom provides a Go library containing the boilerplate for creating Maelstrom Nodes, leaving you to focus on the fun stuff2!\nWith this being so accessible, I guess I‚Äôll be working through the Gossip Glomers as I get time. When I complete a challenge, I‚Äôll also write a post about my thought process3!\nRepository Notes My code can be found on GitHub at lynshi/gossip-glomers. Implementations for each challenge can be found under internal/. Finally, I‚Äôve set up GitHub Actions to run tests for each challenge.\nChallenge 2: Unique ID Generation Challenge 2 is Unique ID Generation. The system must generate globally unique IDs and be totally available, so network partitions must not lead to violation of the uniqueness constraint.\nIn order to be resilient to partitions, we cannot rely on node-to-node communication to synchronize the list of used IDs. One way of ensuring that nodes do not generate conflicting IDs is to split the range of possible IDs across nodes so that none of the ranges overlap.\nWhile the obvious approach is to split the pool of possible IDs in 34, an easier to implement (and subjectively more elegant) method is to have a unique prefix for each node. The prefix can be derived from the node ID (nodes are numbered n1, n2, ‚Ä¶). Then, when asked for an ID, each node will return a locally-unique ID prefixed with its node ID. For example, the first ID generated by node 1 might look like 1-0.\nUpon rereading the prompt, I realized that IDs may be of any type, so the format - suffices to solve the problem. However, I completedly missed this as I was working on it, so I came up with a scheme to create integer IDs.\nSince the test sends 1000 requests per second for 30 seconds, the system is expected to generate 30,000 unique IDs. This means that the set of ID numbers generated by each node must include the range [0, 30000); this fits in a 15-bit number (2^15 = 32768). So, to generate a globally unique ID from a locally unique one, we left-shift the node ID by 15 bits to obtain the prefix, then add the locally unique ID. Overall, our ID generator generates 17-bit IDs5.\nImplementation Naively, the way to create locally unique IDs is to have a counter that starts at 0. Every time a generate message is received, we return the current counter value and increment the counter.\nThere is a small issue ‚Äî presumably, a node can receive concurrent requests. There needs to be a synchronization primitive for the counter to ensure that each counter value is only read once. Normally we would use a lock to protect access, but we are using Go so let‚Äôs do better!\nWe‚Äôll use a channel to provide unique IDs. The channel is initialized with a capacity of 1 so that we generate IDs on-demand, but you could set a higher capacity to have more IDs ready at a time, or even prepopulate with all possible IDs up front6. We use uint32 for the counter to avoid type conversions as the final ID requires 17 bits.\ncounter := make(chan uint32, 1) Next, we‚Äôll start a goroutine to add a new, unique ID whenever the channel is emptied.\ni := uint32(0) go func() { for { select { case \u003c-ctx.Done(): close(counter) return case counter \u003c- i: i++ } } }() With a channel providing unique IDs now available, the unique_ids handler only needs to read a value from the channel to respond to a request. Recall the need to prefix the read ID with the node ID, which we do by shifting the node ID left 15 bits.\nnode_id, err := strconv.Atoi(n.ID()[1:]) if err != nil { return errors.Wrapf(err, \"could not get integer from %s\", n.ID()) } id, ok := \u003c-counter if !ok { return errors.New(\"counter channel closed\") } node_id = node_id \u003c\u003c 15 // ... resp[\"id\"] = uint32(node_id) + id For those curious, errors.Wrapf comes from github.com/pkg/errors, which provides convenient utilities for wrapping errors nicely to bubble up trace information.\nThat‚Äôs all there is to it! The full code can be found at internal/unique_ids/unique_ids.go.\nWe haven‚Äôt even gotten to how to create and run proper tests yet!¬†‚Ü©Ô∏é\nPlus the added benefit of getting to use Go ü§£¬†‚Ü©Ô∏é\nThe first challenge is just a ‚ÄúHello, World!‚Äù for getting you set up, so I‚Äôll skip it.¬†‚Ü©Ô∏é\nIn this challenge, there are only three nodes.¬†‚Ü©Ô∏é\nThe first two bits will be used for the unique prefix (00, 01, and 10).¬†‚Ü©Ô∏é\nBe careful not to create a situation where the channel is unbuffered and you continuously add IDs without an upper limit on the ID value!¬†‚Ü©Ô∏é\n","wordCount":"908","inLanguage":"en","datePublished":"2023-11-26T21:06:12-08:00","dateModified":"2023-11-26T21:06:12-08:00","author":{"@type":"Person","name":"Lyndon Shi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lynshi.github.io/posts/gossip-glomers-intro-and-unique-id-generation/"},"publisher":{"@type":"Organization","name":"Nibbles and Bytes","logo":{"@type":"ImageObject","url":"https://lynshi.github.io/favicon/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lynshi.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://lynshi.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lynshi.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://lynshi.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://lynshi.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lynshi.github.io/>Home</a>&nbsp;¬ª&nbsp;<a href=https://lynshi.github.io/posts/>Posts</a></div><h1 class=post-title>Gossip Glomers: Intro and Unique ID Generation</h1><div class=post-description>Who knew you could practice implementing distributed systems for fun?</div><div class=post-meta><span title='2023-11-26 21:06:12 -0800 -0800'>November 26, 2023</span>&nbsp;¬∑&nbsp;5 min&nbsp;¬∑&nbsp;908 words&nbsp;¬∑&nbsp;Lyndon Shi&nbsp;|&nbsp;<a href=https://github.com/lynshi/blog/tree/main/content/posts/Gossip-Glomers:-Intro-and-Unique-ID-Generation.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>One of the challenges for practicing implementing distributed systems is that it is not easy to simulate the various situations a distributed system might find itself in. Moreover, I previously could not even come up with an easy way to deploy a toy setup; the only thing I could think of is to use <a href=https://minikube.sigs.k8s.io/docs/>minikube</a> and build a Kubernetes-based environment, but frankly at that point it is too much investment for me<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>Fortunately, I recently came across a series of distributed systems challenges created by <a href=https://fly.io/>fly.io</a> and <a href=https://aphyr.com/about>Kyle Kingsbury</a> (author of <a href=https://jepsen.io/>Jepsen</a>): <a href=https://fly.io/dist-sys/>Gossip Glomers</a>. The challenges use <a href=https://github.com/jepsen-io/maelstrom>Maelstrom</a>, a framework for running and testing toy implementations of distributed systems, so that you only have to implement the individual nodes and not worry about anything else. Even better, Maelstrom provides a <a href=https://pkg.go.dev/github.com/jepsen-io/maelstrom/demo/go>Go library</a> containing the boilerplate for creating Maelstrom Nodes, leaving you to focus on the fun stuff<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>!</p><p>With this being so accessible, I guess I&rsquo;ll be working through the Gossip Glomers as I get time. When I complete a challenge, I&rsquo;ll also write a post about my thought process<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>!</p><hr><h1 id=repository-notes>Repository Notes<a hidden class=anchor aria-hidden=true href=#repository-notes>#</a></h1><p>My code can be found on GitHub at <a href=https://github.com/lynshi/gossip-glomers>lynshi/gossip-glomers</a>. Implementations for each challenge can be found under <a href=https://github.com/lynshi/gossip-glomers/tree/main/internal><code>internal/</code></a>. Finally, I&rsquo;ve set up <a href=https://github.com/lynshi/gossip-glomers/blob/main/.github/workflows/tests.yml>GitHub Actions</a> to run tests for each challenge.</p><hr><h1 id=challenge-2-unique-id-generation>Challenge 2: Unique ID Generation<a hidden class=anchor aria-hidden=true href=#challenge-2-unique-id-generation>#</a></h1><p>Challenge 2 is <a href=https://fly.io/dist-sys/2/>Unique ID Generation</a>. The system must generate globally unique IDs and be totally available, so network partitions must not lead to violation of the uniqueness constraint.</p><p>In order to be resilient to partitions, we cannot rely on node-to-node communication to synchronize the list of used IDs. One way of ensuring that nodes do not generate conflicting IDs is to split the range of possible IDs across nodes so that none of the ranges overlap.</p><p>While the obvious approach is to split the pool of possible IDs in 3<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>, an easier to implement (and subjectively more elegant) method is to have a unique prefix for each node. The prefix can be derived from the node ID (nodes are numbered <code>n1</code>, <code>n2</code>, &mldr;). Then, when asked for an ID, each node will return a locally-unique ID prefixed with its node ID. For example, the first ID generated by node 1 might look like <code>1-0</code>.</p><hr><p>Upon rereading the prompt, I realized that IDs may be of any type, so the format <code>&lt;node ID>-&lt;locally incrementing index></code> suffices to solve the problem. However, I completedly missed this as I was working on it, so I came up with a scheme to create integer IDs.</p><p>Since the test sends 1000 requests per second for 30 seconds, the system is expected to generate 30,000 unique IDs. This means that the set of ID numbers generated by each node must include the range <code>[0, 30000)</code>; this fits in a 15-bit number (<code>2^15 = 32768</code>). So, to generate a globally unique ID from a locally unique one, we left-shift the node ID by 15 bits to obtain the prefix, then add the locally unique ID. Overall, our ID generator generates 17-bit IDs<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>.</p><hr><h2 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h2><p>Naively, the way to create locally unique IDs is to have a counter that starts at 0. Every time a <code>generate</code> message is received, we return the current counter value and increment the counter.</p><p>There is a small issue ‚Äî presumably, a node can receive concurrent requests. There needs to be a synchronization primitive for the counter to ensure that each counter value is only read once. Normally we would use a lock to protect access, but we are using Go so let&rsquo;s do better!</p><p>We&rsquo;ll use a channel to provide unique IDs. The channel is initialized with a capacity of 1 so that we generate IDs on-demand, but you could set a higher capacity to have more IDs ready at a time, or even prepopulate with all possible IDs up front<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>. We use <code>uint32</code> for the counter to avoid type conversions as the final ID requires 17 bits.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>counter</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>uint32</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><p>Next, we&rsquo;ll start a goroutine to add a new, unique ID whenever the channel is emptied.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>i</span> <span class=o>:=</span> <span class=nb>uint32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span>
</span></span><span class=line><span class=cl>      <span class=nb>close</span><span class=p>(</span><span class=nx>counter</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nx>counter</span> <span class=o>&lt;-</span> <span class=nx>i</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=nx>i</span><span class=o>++</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}()</span>
</span></span></code></pre></div><p>With a channel providing unique IDs now available, the <code>unique_ids</code> handler only needs to read a value from the channel to respond to a request. Recall the need to prefix the read ID with the node ID, which we do by shifting the node ID left 15 bits.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>node_id</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>Atoi</span><span class=p>(</span><span class=nx>n</span><span class=p>.</span><span class=nf>ID</span><span class=p>()[</span><span class=mi>1</span><span class=p>:])</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Wrapf</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=s>&#34;could not get integer from %s&#34;</span><span class=p>,</span> <span class=nx>n</span><span class=p>.</span><span class=nf>ID</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>id</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>counter</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;counter channel closed&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>node_id</span> <span class=p>=</span> <span class=nx>node_id</span> <span class=o>&lt;&lt;</span> <span class=mi>15</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>resp</span><span class=p>[</span><span class=s>&#34;id&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=nb>uint32</span><span class=p>(</span><span class=nx>node_id</span><span class=p>)</span> <span class=o>+</span> <span class=nx>id</span>
</span></span></code></pre></div><p>For those curious, <code>errors.Wrapf</code> comes from <a href=github.com/pkg/errors><code>github.com/pkg/errors</code></a>, which provides convenient utilities for wrapping errors nicely to bubble up trace information.</p><p>That&rsquo;s all there is to it! The full code can be found at <a href=https://github.com/lynshi/gossip-glomers/blob/main/internal/unique_ids/unique_ids.go><code>internal/unique_ids/unique_ids.go</code></a>.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>We haven&rsquo;t even gotten to how to create and run proper tests yet!&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Plus the added benefit of getting to use Go ü§£&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>The <a href=https://fly.io/dist-sys/1/>first challenge</a> is just a &ldquo;Hello, World!&rdquo; for getting you set up, so I&rsquo;ll skip it.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>In this challenge, there are only three nodes.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>The first two bits will be used for the unique prefix (<code>00</code>, <code>01</code>, and <code>10</code>).&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>Be careful not to create a situation where the channel is unbuffered and you continuously add IDs without an upper limit on the ID value!&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://lynshi.github.io/tags/distributed-systems/>Distributed systems</a></li><li><a href=https://lynshi.github.io/tags/fly.io/>fly.io</a></li><li><a href=https://lynshi.github.io/tags/gossip-glomers/>Gossip Glomers</a></li></ul><nav class=paginav><a class=prev href=https://lynshi.github.io/posts/gossip-glomers-3ac/><span class=title>¬´ Prev</span><br><span>Gossip Glomers 3 (a-c): Single-Node, Multi-Node, and Fault Tolerant Broadcast</span></a>
<a class=next href=https://lynshi.github.io/posts/getting-rid-of-old-clothes-in-seattle/><span class=title>Next ¬ª</span><br><span>Getting Rid of Old Clothes in Seattle</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://lynshi.github.io/>Nibbles and Bytes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>