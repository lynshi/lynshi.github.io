<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Gossip Glomers: Intro and Unique ID Generation | Nibbles and Bytes</title><meta name=keywords content="Distributed systems,fly.io,Gossip Glomers"><meta name=description content="Who knew you could practice implementing distributed systems for fun?"><meta name=author content="Lyndon Shi"><link rel=canonical href=https://lynshi.github.io/posts/gossip-glomers-intro-and-unique-id-generation/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://lynshi.github.io/favicon/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://lynshi.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lynshi.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://lynshi.github.io/favicon/apple-touch-icon.png><link rel=mask-icon href=https://lynshi.github.io/favicon/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})'></script><meta property="og:title" content="Gossip Glomers: Intro and Unique ID Generation"><meta property="og:description" content="Who knew you could practice implementing distributed systems for fun?"><meta property="og:type" content="article"><meta property="og:url" content="https://lynshi.github.io/posts/gossip-glomers-intro-and-unique-id-generation/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-26T21:06:12-08:00"><meta property="article:modified_time" content="2023-11-26T21:06:12-08:00"><meta property="og:site_name" content="Nibbles and Bytes"><meta name=twitter:card content="summary"><meta name=twitter:title content="Gossip Glomers: Intro and Unique ID Generation"><meta name=twitter:description content="Who knew you could practice implementing distributed systems for fun?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lynshi.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Gossip Glomers: Intro and Unique ID Generation","item":"https://lynshi.github.io/posts/gossip-glomers-intro-and-unique-id-generation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Gossip Glomers: Intro and Unique ID Generation","name":"Gossip Glomers: Intro and Unique ID Generation","description":"Who knew you could practice implementing distributed systems for fun?","keywords":["Distributed systems","fly.io","Gossip Glomers"],"articleBody":"One of the challenges for practicing implementing distributed systems is that it is not easy to simulate the various situations a distributed system might find itself in. Moreover, I previously could not even come up with an easy way to deploy a toy setup; the only thing I could think of is to use minikube and build a Kubernetes-based environment, but frankly at that point it is too much investment for me1.\nFortunately, I recently came across a series of distributed systems challenges created by fly.io and Kyle Kingsbury (author of Jepsen): Gossip Glomers. The challenges use Maelstrom, a framework for running and testing toy implementations of distributed systems, so that you only have to implement the individual nodes and not worry about anything else. Even better, Maelstrom provides a Go library containing the boilerplate for creating Maelstrom Nodes, leaving you to focus on the fun stuff2!\nWith this being so accessible, I guess I’ll be working through the Gossip Glomers as I get time. When I complete a challenge, I’ll also write a post about my thought process3!\nRepository Structure My code can be found on GitHub at lynshi/gossip-glomers. Handlers are registered in main.go, while implementations for each challenge can be found under internal/. Each package exposes Add*Handle methods to add handlers for different (Maelstrom-defined) message types.\nThroughout the challenges, I make use of channels4. Though this doesn’t seem strictly necessary for such a toy program, I use Context to inform goroutines when the program is shutting down so that they can close channels before exiting.\nFinally, I’ve set up GitHub Actions to run tests for each challenge.\nChallenge 2: Unique ID Generation Challenge 2 is Unique ID Generation. The system must generate globally unique IDs and be totally available, so network partitions must not lead to violation of the uniqueness constraint.\nIn order to be resilient to partitions, we cannot rely on node-to-node communication to synchronize the list of used IDs. One way of ensuring that nodes do not generate conflicting IDs is to split the range of possible IDs across nodes so that none of the ranges overlap.\nWhile the obvious approach is to split the pool of possible IDs in 35, an easier to implement (and subjectively more elegant) method is to have a unique prefix for each node. The prefix can be derived from the node ID (nodes are numbered n1, n2, …). Then, when asked for an ID, each node will return a locally-unique ID prefixed with its node ID. For example, the first ID generated by node 1 might look like 1-0.\nUpon rereading the prompt, I realized that IDs may be of any type, so the format . suffices to solve the problem. However, I completedly missed this as I was working on it, so I came up with a scheme to create integer IDs.\nSince the test sends 1000 requests per second for 30 seconds, the system is expected to generate 30,000 unique IDs. This means that the set of ID numbers generated by each node must include the range [0, 30000); this fits in a 15-bit number (2^15 = 32768). So, to generate a globally unique ID from a locally unique one, we left-shift the node ID by 15 bits to obtain the prefix, then add the locally unique ID. Overall, our ID generator generates 17-bit IDs6.\nImplementation Naively, the way to create locally unique IDs is to have a counter that starts at 0. Every time a generate message is received, we return the current counter value and increment the counter.\nThere is a small issue — presumably, a node can receive concurrent requests. There needs to be a synchronization primitive for the counter to ensure that each counter value is only read once. Normally we would use a lock to protect access, but we are using Go so let’s do better!\nWe’ll use a channel to provide unique IDs. The channel is initialized with a capacity of 1 so that we generate IDs on-demand, but you could set a higher capacity to have more IDs ready at a time, or even prepopulate with all possible IDs up front7. We use uint32 for the counter to avoid type conversions as the final ID requires 17 bits.\ncounter := make(chan uint32, 1) Next, we’ll start a goroutine to add a new, unique ID whenever the channel is emptied.\ni := uint32(0) go func() { for { select { case \u003c-ctx.Done(): close(counter) return case counter \u003c- i: i++ } } }() With a channel providing unique IDs now available, the unique_ids handler only needs to read a value from the channel to respond to a request. Recall the need to prefix the read ID with the node ID, which we do by shifting the node ID left 15 bits.\nnode_id, err := strconv.Atoi(n.ID()[1:]) if err != nil { return errors.Wrapf(err, \"could not get integer from %s\", n.ID()) } id, ok := \u003c-counter if !ok { return errors.New(\"counter channel closed\") } node_id = node_id \u003c\u003c 15 // ... resp[\"id\"] = uint32(node_id) + id For those curious, errors.Wrapf comes from github.com/pkg/errors, which provides convenient utilities for wrapping errors nicely to bubble up trace information.\nThat’s all there is to it! The full code can be found at internal/unique_ids/unique_ids.go.\nWe haven’t even gotten to how to create and run proper tests yet! ↩︎\nPlus the added benefit of getting to use Go 🤣 ↩︎\nThe first challenge is just a “Hello, World!” for getting you set up, so I’ll skip it. ↩︎\nChannels are the most beautiful thing about Go and thus I will avoid locks whenever I can. ↩︎\nIn this challenge, there are only three nodes. ↩︎\nThe first two bits will be used for the unique prefix (00, 01, and 10). ↩︎\nBe careful not to create a situation where the channel is unbuffered and you continuously add IDs without an upper limit on the ID value! ↩︎\n","wordCount":"983","inLanguage":"en","datePublished":"2023-11-26T21:06:12-08:00","dateModified":"2023-11-26T21:06:12-08:00","author":{"@type":"Person","name":"Lyndon Shi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lynshi.github.io/posts/gossip-glomers-intro-and-unique-id-generation/"},"publisher":{"@type":"Organization","name":"Nibbles and Bytes","logo":{"@type":"ImageObject","url":"https://lynshi.github.io/favicon/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lynshi.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://lynshi.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lynshi.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://lynshi.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://lynshi.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://lynshi.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lynshi.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://lynshi.github.io/posts/>Posts</a></div><h1 class=post-title>Gossip Glomers: Intro and Unique ID Generation</h1><div class=post-description>Who knew you could practice implementing distributed systems for fun?</div><div class=post-meta><span title='2023-11-26 21:06:12 -0800 -0800'>November 26, 2023</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;983 words&nbsp;·&nbsp;Lyndon Shi&nbsp;|&nbsp;<a href=https://github.com/lynshi/blog/tree/main/content/posts/Gossip-Glomers:-Intro-and-Unique-ID-Generation.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>One of the challenges for practicing implementing distributed systems is that it is not easy to simulate the various situations a distributed system might find itself in. Moreover, I previously could not even come up with an easy way to deploy a toy setup; the only thing I could think of is to use <a href=https://minikube.sigs.k8s.io/docs/>minikube</a> and build a Kubernetes-based environment, but frankly at that point it is too much investment for me<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>Fortunately, I recently came across a series of distributed systems challenges created by <a href=https://fly.io/>fly.io</a> and <a href=https://aphyr.com/about>Kyle Kingsbury</a> (author of <a href=https://jepsen.io/>Jepsen</a>): <a href=https://fly.io/dist-sys/>Gossip Glomers</a>. The challenges use <a href=https://github.com/jepsen-io/maelstrom>Maelstrom</a>, a framework for running and testing toy implementations of distributed systems, so that you only have to implement the individual nodes and not worry about anything else. Even better, Maelstrom provides a <a href=https://pkg.go.dev/github.com/jepsen-io/maelstrom/demo/go>Go library</a> containing the boilerplate for creating Maelstrom Nodes, leaving you to focus on the fun stuff<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>!</p><p>With this being so accessible, I guess I&rsquo;ll be working through the Gossip Glomers as I get time. When I complete a challenge, I&rsquo;ll also write a post about my thought process<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>!</p><hr><h1 id=repository-structure>Repository Structure<a hidden class=anchor aria-hidden=true href=#repository-structure>#</a></h1><p>My code can be found on GitHub at <a href=https://github.com/lynshi/gossip-glomers>lynshi/gossip-glomers</a>. Handlers are registered in <a href=https://github.com/lynshi/gossip-glomers/blob/main/main.go>main.go</a>, while implementations for each challenge can be found under <a href=https://github.com/lynshi/gossip-glomers/tree/main/internal><code>internal/</code></a>. Each package exposes <code>Add*Handle</code> methods to add handlers for different (Maelstrom-defined) message types.</p><p>Throughout the challenges, I make use of channels<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>. Though this doesn&rsquo;t seem strictly necessary for such a toy program, I use <a href=https://pkg.go.dev/context><code>Context</code></a> to inform goroutines when the program is shutting down so that they can close channels before exiting.</p><p>Finally, I&rsquo;ve set up <a href=https://github.com/lynshi/gossip-glomers/blob/main/.github/workflows/tests.yml>GitHub Actions</a> to run tests for each challenge.</p><hr><h1 id=challenge-2-unique-id-generation>Challenge 2: Unique ID Generation<a hidden class=anchor aria-hidden=true href=#challenge-2-unique-id-generation>#</a></h1><p>Challenge 2 is <a href=https://fly.io/dist-sys/2/>Unique ID Generation</a>. The system must generate globally unique IDs and be totally available, so network partitions must not lead to violation of the uniqueness constraint.</p><p>In order to be resilient to partitions, we cannot rely on node-to-node communication to synchronize the list of used IDs. One way of ensuring that nodes do not generate conflicting IDs is to split the range of possible IDs across nodes so that none of the ranges overlap.</p><p>While the obvious approach is to split the pool of possible IDs in 3<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>, an easier to implement (and subjectively more elegant) method is to have a unique prefix for each node. The prefix can be derived from the node ID (nodes are numbered <code>n1</code>, <code>n2</code>, &mldr;). Then, when asked for an ID, each node will return a locally-unique ID prefixed with its node ID. For example, the first ID generated by node 1 might look like <code>1-0</code>.</p><hr><p>Upon rereading the prompt, I realized that IDs may be of any type, so the format <code>&lt;node ID>.&lt;locally incrementing index></code> suffices to solve the problem. However, I completedly missed this as I was working on it, so I came up with a scheme to create integer IDs.</p><p>Since the test sends 1000 requests per second for 30 seconds, the system is expected to generate 30,000 unique IDs. This means that the set of ID numbers generated by each node must include the range <code>[0, 30000)</code>; this fits in a 15-bit number (<code>2^15 = 32768</code>). So, to generate a globally unique ID from a locally unique one, we left-shift the node ID by 15 bits to obtain the prefix, then add the locally unique ID. Overall, our ID generator generates 17-bit IDs<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>.</p><hr><h2 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h2><p>Naively, the way to create locally unique IDs is to have a counter that starts at 0. Every time a <code>generate</code> message is received, we return the current counter value and increment the counter.</p><p>There is a small issue — presumably, a node can receive concurrent requests. There needs to be a synchronization primitive for the counter to ensure that each counter value is only read once. Normally we would use a lock to protect access, but we are using Go so let&rsquo;s do better!</p><p>We&rsquo;ll use a channel to provide unique IDs. The channel is initialized with a capacity of 1 so that we generate IDs on-demand, but you could set a higher capacity to have more IDs ready at a time, or even prepopulate with all possible IDs up front<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>. We use <code>uint32</code> for the counter to avoid type conversions as the final ID requires 17 bits.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>counter</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>uint32</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><p>Next, we&rsquo;ll start a goroutine to add a new, unique ID whenever the channel is emptied.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>i</span> <span class=o>:=</span> <span class=nb>uint32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span>
</span></span><span class=line><span class=cl>      <span class=nb>close</span><span class=p>(</span><span class=nx>counter</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nx>counter</span> <span class=o>&lt;-</span> <span class=nx>i</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=nx>i</span><span class=o>++</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}()</span>
</span></span></code></pre></div><p>With a channel providing unique IDs now available, the <code>unique_ids</code> handler only needs to read a value from the channel to respond to a request. Recall the need to prefix the read ID with the node ID, which we do by shifting the node ID left 15 bits.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>node_id</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>Atoi</span><span class=p>(</span><span class=nx>n</span><span class=p>.</span><span class=nf>ID</span><span class=p>()[</span><span class=mi>1</span><span class=p>:])</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Wrapf</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=s>&#34;could not get integer from %s&#34;</span><span class=p>,</span> <span class=nx>n</span><span class=p>.</span><span class=nf>ID</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>id</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>counter</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;counter channel closed&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>node_id</span> <span class=p>=</span> <span class=nx>node_id</span> <span class=o>&lt;&lt;</span> <span class=mi>15</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>resp</span><span class=p>[</span><span class=s>&#34;id&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=nb>uint32</span><span class=p>(</span><span class=nx>node_id</span><span class=p>)</span> <span class=o>+</span> <span class=nx>id</span>
</span></span></code></pre></div><p>For those curious, <code>errors.Wrapf</code> comes from <a href=github.com/pkg/errors><code>github.com/pkg/errors</code></a>, which provides convenient utilities for wrapping errors nicely to bubble up trace information.</p><p>That&rsquo;s all there is to it! The full code can be found at <a href=https://github.com/lynshi/gossip-glomers/blob/main/internal/unique_ids/unique_ids.go><code>internal/unique_ids/unique_ids.go</code></a>.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>We haven&rsquo;t even gotten to how to create and run proper tests yet!&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Plus the added benefit of getting to use Go 🤣&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>The <a href=https://fly.io/dist-sys/1/>first challenge</a> is just a &ldquo;Hello, World!&rdquo; for getting you set up, so I&rsquo;ll skip it.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>Channels are the most beautiful thing about Go and thus I will avoid locks whenever I can.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>In this challenge, there are only three nodes.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>The first two bits will be used for the unique prefix (<code>00</code>, <code>01</code>, and <code>10</code>).&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>Be careful not to create a situation where the channel is unbuffered and you continuously add IDs without an upper limit on the ID value!&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://lynshi.github.io/tags/distributed-systems/>Distributed systems</a></li><li><a href=https://lynshi.github.io/tags/fly.io/>fly.io</a></li><li><a href=https://lynshi.github.io/tags/gossip-glomers/>Gossip Glomers</a></li></ul><nav class=paginav><a class=next href=https://lynshi.github.io/posts/getting-rid-of-old-clothes-in-seattle/><span class=title>Next »</span><br><span>Getting Rid of Old Clothes in Seattle</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Gossip Glomers: Intro and Unique ID Generation on twitter" href="https://twitter.com/intent/tweet/?text=Gossip%20Glomers%3a%20Intro%20and%20Unique%20ID%20Generation&url=https%3a%2f%2flynshi.github.io%2fposts%2fgossip-glomers-intro-and-unique-id-generation%2f&hashtags=Distributedsystems%2cfly.io%2cGossipGlomers"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Gossip Glomers: Intro and Unique ID Generation on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2flynshi.github.io%2fposts%2fgossip-glomers-intro-and-unique-id-generation%2f&title=Gossip%20Glomers%3a%20Intro%20and%20Unique%20ID%20Generation&summary=Gossip%20Glomers%3a%20Intro%20and%20Unique%20ID%20Generation&source=https%3a%2f%2flynshi.github.io%2fposts%2fgossip-glomers-intro-and-unique-id-generation%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Gossip Glomers: Intro and Unique ID Generation on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flynshi.github.io%2fposts%2fgossip-glomers-intro-and-unique-id-generation%2f&title=Gossip%20Glomers%3a%20Intro%20and%20Unique%20ID%20Generation"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://lynshi.github.io/>Nibbles and Bytes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>