<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Understanding EWD998: Shmuel Safra's version of termination detection | Nibbles and Bytes</title><meta name=keywords content="Distributed systems,TLA+"><meta name=description content="Oh no, there are math symbols!"><meta name=author content="Lyndon Shi"><link rel=canonical href=http://lynshi.github.io/posts/understanding-ewd998/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://lynshi.github.io/favicon/favicon.png><link rel=icon type=image/png sizes=16x16 href=http://lynshi.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://lynshi.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=http://lynshi.github.io/favicon/apple-touch-icon.png><link rel=mask-icon href=http://lynshi.github.io/favicon/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})'></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Understanding EWD998: Shmuel Safra's version of termination detection"><meta property="og:description" content="Oh no, there are math symbols!"><meta property="og:type" content="article"><meta property="og:url" content="http://lynshi.github.io/posts/understanding-ewd998/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-18T21:55:07-08:00"><meta property="article:modified_time" content="2023-02-18T21:55:07-08:00"><meta property="og:site_name" content="Nibbles and Bytes"><meta name=twitter:card content="summary"><meta name=twitter:title content="Understanding EWD998: Shmuel Safra's version of termination detection"><meta name=twitter:description content="Oh no, there are math symbols!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://lynshi.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Understanding EWD998: Shmuel Safra's version of termination detection","item":"http://lynshi.github.io/posts/understanding-ewd998/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Understanding EWD998: Shmuel Safra's version of termination detection","name":"Understanding EWD998: Shmuel Safra\u0027s version of termination detection","description":"Oh no, there are math symbols!","keywords":["Distributed systems","TLA+"],"articleBody":"I‚Äôll soon be attending Markus Kuppe‚Äôs workshop on TLA+ and one of the pre-read materials is Dijkstra‚Äôs EWD998 - Shmuel Safra‚Äôs version of termination detection. I haven‚Äôt read a serious, academic paper since college like 3 years ago1, so it was quite an adventure getting back into the swing of things. As I was reading, I spent a lot of time going back and forth to make things make sense, because the hallmark of a real paper is that you can‚Äôt just consume it in one go if you actually want to understand the material.\nOne of the nice things about a college course/lecture is that you get the teacher‚Äôs notes edition of the paper/proof. You get the ‚Äúwhy‚Äù behind statements in the paper, not just how. Whereas if I‚Äôm reading a paper by myself, I often have to pause and ask ‚ÄúWell, I see that you‚Äôve gone from Point A to Point B, and I believe your logic was sound, but why did we do that? And how on earth did you come up with Point A in the first place?!‚Äù\nSo, after I spent a good chunk of my time unwrapping this paper, I figured I could throw something onto the Internet to make someone else‚Äôs reading a little easier. Read on for what is essentially EWD998 restated with longer explanations where Dijkstra‚Äôs brevity forced me to stop and think :)\nThe premise of the paper is that there‚Äôs a circle of $N$ machines indexed from 0. Each machine is either active or passive. Active machines may send messages to other machines. These messages take time to travel between machines; however, no messages are ever lost. An active machine can become passive ‚Äúspontaneously‚Äù. Meanwhile, a passive machine only becomes active upon receipt of a message.\nWe want to figure out when the system is stable; that is, all machines are passive and there are no messages in transit. We‚Äôre going to devise a solution where the first machine, $m_0$2, can detect when the system has reached a stable state (i.e. termination). This termination detection algorithm is called ‚Äúthe probe‚Äù.\nThe machines, regardless of their active/passive status, can always communicate such that:\nMachine $m_0$ can kick off the probe by sending a signal (i.e. a token) to $m_{N - 1}$. $m_{i + 1}$ can always propogate the probe by sending the token to $m_{i}$, even if $m_{i + 1}$ is passive. Eventually, this token makes its way back to $m_0$. Based on information on the token and the state of $m_0$, we‚Äôll be able to conclude whether the stable state has been reached3.\nThe strategy for solving this problem is to iteratively construct an invariant $P$ that is always true in the system and rules to maintain the invariant. This invariant will help us determine the conditions that are satisfied if and only if the system is stable when the token returns to $m_0$.\nConcretely, we‚Äôll\nConstruct an invariant. Devise a rule for system operation to maintain it. Find an edge case that causes the invariant to break. Each edge case can be addressed by adding a new condition to the invariant, so we loop back to 1. When we add a new condition, we have to be careful that the condition still allows us to detect termination.\nBased on Dijkstra‚Äôs closing4, this strategy seem to have been discussed for some time, which explains why EWD998 reads so matter-of-factly5. But here I‚Äôm telling you up front what to expect, so you don‚Äôt have to tear your hair out wondering what magic possessed Safra such that the logic moves so effortlessly from step to step!\nLet $t$ be the index of the machine holding the token and $B$ be the number of messages on their way. We would like to determine whether the system has reached stable state when the token returns to $m_0$ (i.e. $t = 0$), and our definitions mean that termination can be stated as6 $$\\forall i \\in [0, N): m_i \\text{ is passive} \\land B = 0$$\nIn other words, the system is stable if all machines are passive and no messages are on their way (to wake up a machine).\nIt‚Äôs clear we need to know $B$ to detect termination. If we knew how many messages had been sent and received by each machine, we can easily compute $B$. Thus, let‚Äôs construct our first invariant, $P_0$, to help us keep track of $B$.\n$$P_0: \\quad B = \\Sigma_{i = 0}^{N - 1}c_i$$\nIntuitively, we want $c_i$ to be the net messages sent by machine $i$, and we enforce this by adding a rule to the system.\nRule 0: Each machine maintains its own counter $c_i$, incrementing it by 1 when it sends a message and decrementing it by 1 when it receives a message7. It follows that we should initialize all $c_i$ to 0 when the machines first start.\n$P_0$ doesn‚Äôt depend on $t$, so $m_0$ receiving the token after it has been sent around the ring doesn‚Äôt help us determine anything. Consequently, let‚Äôs say that the token has a value $q$ and add a condition $P_1$.\n$$P_1: \\quad \\forall i \\in (t, N): m_i \\text{ is passive} \\land \\Sigma_{i = t + 1}^{N - 1}c_i = q$$\nIf $P_1$ is true, that means that all machines that have already handled the token are passive, and the sum of their counters $c_i$ is equal to the value of the token. The token being integer-valued and connected to the $c_i$ is critical to the termination detection algorithm as it encodes information about $B$, which is hard to know without an overall view of the system, into something that can be passed around8.\nNow, our invariant is $P_0 \\land P_1$. If the invariant holds, when the token returns at $t = 0$,\n$$ \\begin{aligned} \u0026 P_0 \\land P_1 \\land t = 0 \\\\ \\implies \u0026 B = \\Sigma_{i = 0}^{N - 1}c_i \\land \\forall i \\in (0, N): m_i \\text{ is passive} \\land \\Sigma_{i = 1}^{N - 1}c_i = q \\\\ \\implies \u0026 B = c_0 + q \\land \\forall i \\in (0, N): m_i \\text{ is passive} \\end{aligned} $$\nThat is, all machines other than $m_0$ are passive (plus the little equation, $c_0 + q = B$, that follows from some arithmetic).\nRecall that all machines are passive and $B = 0$ when the system is stable. Thus, given the invariant, the system is stable when $t = 0$ if $m_0$ is passive (it‚Äôs the only machine we aren‚Äôt certain about the state of) and $c_0 + q = 0$.\nHow do we maintain $P_1$? Observe that the probe starts with $t = N - 1, q = 0$. The boundary conditions mean that at this point, there are no terms in the $\\forall$ and $\\Sigma$ operations, so while we aren‚Äôt making a statement on which machines are passive, we are stating that $q$ must be 0 since there‚Äôs nothing being summed. That leads us to Rule 1.\nRule 1: When the probe starts, $m_0$ sends the token with a value of 0 (i.e. $q = 0$) to $m_{N - 1}$.\nWhen a machine transmits the token, due to the invariant it must be making a statement that it is passive. It also must update the value of the token. Thus, we introduce Rule 2.\nRule 2: A machine $m_{i + 1}$ only transmits the token to the next machine $m_i$ after $m_{i + 1}$ becomes passive, and the token‚Äôs value is updated to $q = q + c_{i + 1}$.\nWhen is $P_1$ false? Most directly, $P_1$ is false if, when the token is at index $t$, some machine $m_i$, $t \u003c i \u003c N$, is active or $\\Sigma_{i = t + 1}^{N - 1}c_i \\neq q$. Let $m_i$ be the first machine to cause a violation of $P_1$.\nSuppose $m_i$ violates $P_1$ by becoming active. Recall that a machine only forwards the token when it becomes passive, so if $m_i$ is now active, it must have received a message.\nMeanwhile, suppose $\\Sigma_{j = t + 1}^{N - 1}c_j \\neq q$. Since $m_i$ is the first machine to cause a violation of $P_1$, $\\Sigma_{j = i + 1}^{N - 1}c_j = q_i$ (let $q_k$ be the value of the token when $m_k$ received it) must have been true for the whole period during which $m_i$ held the token. By Rule 2, $\\Sigma_{j = i}^{N - 1} = q_{i - 1}$ must also be true when $m_i$ transmits the token, and remain true until the violation is caused by $m_i$. A violation can be caused by $m_i$ if $c_i$ changes. As $m_i$ is passive, $c_i$ can only change via receipt of a message.\nWe conclude that the only way for $m_i$ to cause a violation of $P_1$ is by receiving a message. In real world terms, this means that $m_i$ was woken up by a message that was either still in-transit or yet to be sent when it became passive. Further, in the instance right before the violation, there must be a message on its way to $m_i$. This is expressed by $B \\geq 1$.\nSince $P_0 \\land P_1$ is true the moment before $P_1$ is violated, we have\n$$ \\begin{aligned} 1 \\leq B = \u0026 \\Sigma_{i = 0}^{N - 1}c_i \\\\ B = \u0026 \\Sigma_{i = 0}^{t}c_i + \\Sigma_{i = t + 1}^{N - 1}c_i \\\\ B = \u0026 \\Sigma_{i = 0}^{t}c_i + q \\\\ \\therefore 0 \u003c 1 \u0026\\leq \\Sigma_{i = 0}^{t}c_i + q \\\\ \\\\ P_2: \\quad \\quad \\quad \u0026 \\Sigma_{i = 0}^{t}c_i + q \u003e 0 \\end{aligned} $$\nObserve that $P_2$ is true even if $m_i$, $t \u003c i \u003c N$, receives a message because no machine with $i \u003e t$ is involved in the statement. So we can say either $P_1$ or $P_2$ is true, and our invariant becomes $P_0 \\land (P_1 \\lor P_2)$.\nWhen the probe concludes at $t = 0$, $P_2$ evaluates as $c_0 + q \u003e 0$. Recall that when the system is stable, we have $c_0 + q = 0$, so $P_2$ must be false when that occurs. Thus, the invariant returns to just $P_0 \\land P_1$ when $c_0 + q = 0$, and we already know how to conclude termination when $P_0 \\land P_1$. As a result, introducing $P_2$ does not make it any harder to conclude termination.\nIt‚Äôs getting gnarly now! Under $P_2$, $m_i$ where $0 \\leq i \\leq t$ is free to send as many messages as desired - doing so only increases $c_i$, so the invariant is maintained. However, if $c_i$ decreases due to $m_i$ receiving a message, we might falsify $P_2$! So, let‚Äôs add a statement to the invariant to capture the receipt of a message by $m_i$.\n$$ P_3: \\quad \\exists i \\in [0, t]: \\text{machine } i \\text{ is black} $$\nWe also add a corresponding Rule 3.\nRule 3: When a machine receives a message, it changes its color to black.\nFortunately, this still doesn‚Äôt make it any harder to detect termination. Our invariant is now $P_0 \\land (P_1 \\lor P_2 \\lor P_3)$, and we already know that $P_2$ is false at termination, so we just need to make sure that $P_3$ is also false at termination.\nAt $t = 0$, when we can try to determine termination, $m_0$ must be black to satisfy $P_3$. If $P_3$ is false, we can apply our previously derived techniques for detecting termination; thus, if $m_0$ is white when the token returns, we have a shot at detecting termination.\nWhat, you thought we were going to stop at $P_3$? Nope! If a black machine propagates the token, we are in danger of violating $P_3$ since that machine falls out of the set of machines referenced in $P_3$. This doesn‚Äôt necessarily mean the full invariant is invalidated as other parts of it can be true, so let‚Äôs construct a scenario where $P_1$ and $P_2$ are also false when a black machine propagates the token.\nLet $m_t$, $t \u003e 0$ be the last black machine. Suppose that machines $m_i$, $i \u003c t$ have $c_i = 0$ and are white. While $m_t$ holds the token, it sends a message to $m_x$, $x \u003e t$ - this breaks $P_1$!\nThen, $m_t$ passes the token to $m_{t - 1}$. Suddenly, $P_2$ is falsified as $\\sum_{i = 0}^{t - 1}c_i = 0$. Meanwhile, no machines $0..t - 1$ received a message, so all machines within the set described in $P_3$ are white and $P_3$ is false too!\nClearly, we have to introduce $P_4$ to rectify the situation. Let‚Äôs color the token!\n$$P_4: \\quad \\text{the token is black}$$\nRule 4: If a black machine is to transmit the token, it colors the token black before sending it.\nIf the token is white when it makes it back to $m_0$, then $P_4$ is false, and we have a chance at detecting termination.\nAt this point, we are done modifying the invariant! The color of the token never changes back to white from black, so it can never be made untrue at some later step.\nOverall, we constructed the invariant as follows:\nConstructed $P_1$. $P_1$ can be falsified by the receipt of a message by $m_i$, $t \u003c i \u003c N$, so we constructed $P_2$ which is true at least as early as the instant before $P_1$ becomes false. $P_2$ can be falsified by receipt of a message by $m_i$, $0 \\leq i \\leq t$, so we constructed $P_3$, which becomes true the instant $m_i$ receives a message. $P_3$ can be falsified by the last black machine transmitting the token, so we constructed $P_4$, which becomes true whenever any black machine transmits the token. Once true, $P_4$ never becomes false. Thus, by construction our invariant holds for all states in the system.\nLet us summarize what we know so far. The invariant $P_0 \\land (P_1 \\lor P_2 \\lor P_3 \\lor P_4)$ is always true. $P_0$ is true by design, and we know how to detect termination when $P_0 \\land P_1$. By the invariant, $P_1$ must be true if $P_2$, $P_3$, and $P_4$ are all false. Thus, we have a chance at detecting termination when the token returns at $t = 0$ if:\n$c_0 + q = 0 \\implies \\neg P_2$ (i.e. $P_2$ is false) $m_0 \\text{ is white} \\implies \\neg P_3$ $\\text{The token is white} \\implies \\neg P_4$ When only $P_1$ is true when the token returns, all machines $1..N-1$ are passive, so the system is totally passive if $m_0$ is also passive.\nThus, points 1-3 and $m_0$ being passive at $t = 0$ are the conditions for concluding that the system has reached stable state.\nWhat happens if any of the conditions are false? Well, we can‚Äôt make a conclusive determination, so we run the probe again - what, you thought we could only probe once?\nRule 5: $m_0$ initiates another probe after an unsuccessful probe.\nRunning the probe again is insufficient though! If the token can‚Äôt change back to white, the outcome of the next probe will be no different ($P_4$ will always be true). Further, even if the token color can change, if machine colors don‚Äôt change, then either $m_0$ stays black or the token is turned back to black as it makes its way around the ring. Consequently, we need to be able to change colors for both the token and all machines.\nWhile changing colors back to white, we must be careful to ensure the invariant $P_0 \\land (P_1 \\lor P_2 \\lor P_3 \\lor P_4)$ is maintained! Otherwise, all of our good work will have gone to waste.\nNote that the invariant is true when the probe is first started. $P_0$ is always true thanks to Rule 0, and we established earlier that $P_1$ is trivially true when $m_0$ sends the token to $m_{N - 1}$. So, we can whiten $m_0$ and the token when initiating the probe again.\nRule 6: At initiation of the probe, $m_0$ whitens itself and the token.\nAdditionally, note that $P_3$ only makes a statement about machines whose index is $t$ or less. As a result, it‚Äôs always safe to whiten a machine whose index exceeds $t$.\nRule 7: After transmitting the token to $m_i$, $m_{i + 1}$ whitens itself.\nIt follows that when no messages are in-flight ($B = 0$), no machines turn black anymore, all black machines whiten themselves eventually, and the token eventually stays white. When $B=0$ and all machines are passive, every $c_i$ becomes constant because no machine is able to send messages and there are no messages in transit that might decrease some $c_i$. When a probe is started during such a state, $P_1$ stays true throughout the probe. When the probe ends, $c_0 + q = B = 0$. Therefore, all conditions for detecting termination eventually become true after the system becomes passive!\nExhausted? That makes two of us!\nI started writing this post while I was reading EWD998, but I‚Äôve already completed the workshop and have yet to publish it üòÖ\nSo, I‚Äôll take this opportunity to note that the workshop was terrific! Many thanks and kudos to Markus for putting together such a great experience. We implemented the termination detection algorithm - you can see my spec here - and I learned a lot about TLA+! Hopefully I‚Äôll get a chance to write a spec for some of the systems I‚Äôve designed to catch all the edge cases I undoubtedly have missed.\nAckchyually, I read the Raft paper when I first started working (technically still almost 3 years ago though!) and Paxos vs Raft: Have we reached consensus on distributed consensus? sometime last year. But they didn‚Äôt have any mathematical notation, so my brain didn‚Äôt really get fried and therefore it doesn‚Äôt count.¬†‚Ü©Ô∏é\nDijkstra uses the term nr.i to refer to machine i, but that doesn‚Äôt look good and is even a little confusing in LaTeX.¬†‚Ü©Ô∏é\nThis concludes the easy part! If I were a student, I‚Äôd be worried about plagiarism because I‚Äôm almost quoting the paper verbatim so far. Thankfully, we don‚Äôt have to be so rigorous here.¬†‚Ü©Ô∏é\n‚ÄúNeither the algorithm nor its variations are the point of the note, which is about the derivation strategy, which worked again.‚Äù¬†‚Ü©Ô∏é\nEWD998 references EWD840, which solves a similar problem with the assumption of instantaneous message delivery. EWD840 feels a bit more accessible - maybe because I read (*cough* skimmed) it after EWD998, but it also seems to contain a bit more color on why certain steps are taken.¬†‚Ü©Ô∏é\nDijkstra uses $\\underline{A}$, $\\underline{S}$, and $\\underline{E}$ for $\\forall$ (for all), $\\Sigma$ (sum), and $\\exists$ (exists), respectively. I‚Äôll use the math symbols since they‚Äôre more familiar to me. All ranges are over integers, so $[0, 5) = \\{ 0, 1, 2, 3, 4 \\}$.¬†‚Ü©Ô∏é\nDijkstra remarks that because the value of $B$ changes in a distributed fashion (i.e. based on the individual sending/receiving actions of each machine), our only option to compute $B$ is to try to compute it in a distributed fashion too. Sounds reasonable to me!¬†‚Ü©Ô∏é\nThis explains why Dijkstra‚Äôs previous solution in EWD840 only uses a colored token. In that scenario, messages are delivered instantaneously, so we don‚Äôt have to worry about keeping track of how many messages are in-flight. This also suggests that an integer-valued token (as well as formulation of the problem) was Shmuel Safra‚Äôs key contribution.¬†‚Ü©Ô∏é\n","wordCount":"3214","inLanguage":"en","datePublished":"2023-02-18T21:55:07-08:00","dateModified":"2023-02-18T21:55:07-08:00","author":{"@type":"Person","name":"Lyndon Shi"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://lynshi.github.io/posts/understanding-ewd998/"},"publisher":{"@type":"Organization","name":"Nibbles and Bytes","logo":{"@type":"ImageObject","url":"http://lynshi.github.io/favicon/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://lynshi.github.io/ accesskey=h title="Home (Alt + H)"><img src=http://lynshi.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://lynshi.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://lynshi.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://lynshi.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://lynshi.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://lynshi.github.io/>Home</a>&nbsp;¬ª&nbsp;<a href=http://lynshi.github.io/posts/>Posts</a></div><h1 class=post-title>Understanding EWD998: Shmuel Safra's version of termination detection</h1><div class=post-description>Oh no, there are math symbols!</div><div class=post-meta><span title='2023-02-18 21:55:07 -0800 -0800'>February 18, 2023</span>&nbsp;¬∑&nbsp;16 min&nbsp;¬∑&nbsp;3214 words&nbsp;¬∑&nbsp;Lyndon Shi&nbsp;|&nbsp;<a href=https://github.com/lynshi/blog/tree/main/content/posts/understanding-ewd998.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>I‚Äôll soon be attending <a href=https://twitter.com/lemmster>Markus Kuppe</a>‚Äôs <a href=https://github.com/tlaplus-workshops/ewd998>workshop on TLA+</a> and one of the pre-read materials is <a href=https://www.cs.utexas.edu/users/EWD/ewd09xx/EWD998.PDF>Dijkstra‚Äôs EWD998 - Shmuel Safra&rsquo;s version of termination detection</a>. I haven‚Äôt read a serious, academic paper since college like 3 years ago<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, so it was quite an adventure getting back into the swing of things. As I was reading, I spent a lot of time going back and forth to make things make sense, because the hallmark of a real paper is that you can‚Äôt just consume it in one go if you actually want to understand the material.</p><p>One of the nice things about a college course/lecture is that you get the teacher‚Äôs notes edition of the paper/proof. You get the ‚Äúwhy‚Äù behind statements in the paper, not just how. Whereas if I‚Äôm reading a paper by myself, I often have to pause and ask ‚ÄúWell, I see that you‚Äôve gone from Point A to Point B, and I believe your logic was sound, but why did we do that? And how on earth did you come up with Point A in the first place?!‚Äù</p><p>So, after I spent a good chunk of my time unwrapping this paper, I figured I could throw something onto the Internet to make someone else‚Äôs reading a little easier. Read on for what is essentially EWD998 restated with longer explanations where Dijkstra&rsquo;s brevity forced me to stop and think :)</p><hr><p>The premise of the paper is that there‚Äôs a circle of $N$ machines indexed from 0. Each machine is either active or passive. Active machines may send messages to other machines. These messages take time to travel between machines; however, no messages are ever lost. An active machine can become passive &ldquo;spontaneously&rdquo;. Meanwhile, a passive machine only becomes active upon receipt of a message.</p><p>We want to figure out when the system is stable; that is, all machines are passive and there are no messages in transit. We‚Äôre going to devise a solution where the first machine, $m_0$<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>, can detect when the system has reached a stable state (i.e. termination). This termination detection algorithm is called &ldquo;the probe&rdquo;.</p><p>The machines, regardless of their active/passive status, can always communicate such that:</p><ol><li>Machine $m_0$ can kick off the probe by sending a signal (i.e. a <em>token</em>) to $m_{N - 1}$.</li><li>$m_{i + 1}$ can always propogate the probe by sending the token to $m_{i}$, even if $m_{i + 1}$ is passive.</li></ol><p>Eventually, this token makes its way back to $m_0$. Based on information on the token and the state of $m_0$, we&rsquo;ll be able to conclude whether the stable state has been reached<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><hr><p>The strategy for solving this problem is to iteratively construct an invariant $P$ that is always true in the system and rules to maintain the invariant. This invariant will help us determine the conditions that are satisfied if and only if the system is stable when the token returns to $m_0$.</p><p>Concretely, we&rsquo;ll</p><ol><li>Construct an invariant.</li><li>Devise a rule for system operation to maintain it.</li><li>Find an edge case that causes the invariant to break.</li></ol><p>Each edge case can be addressed by adding a new condition to the invariant, so we loop back to 1. When we add a new condition, we have to be careful that the condition still allows us to detect termination.</p><p>Based on Dijkstra&rsquo;s closing<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>, this strategy seem to have been discussed for some time, which explains why EWD998 reads so matter-of-factly<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>. But here I&rsquo;m telling you up front what to expect, so you don&rsquo;t have to tear your hair out wondering what magic possessed Safra such that the logic moves so effortlessly from step to step!</p><hr><p>Let $t$ be the index of the machine holding the token and $B$ be the number of messages on their way. We would like to determine whether the system has reached stable state when the token returns to $m_0$ (i.e. $t = 0$), and our definitions mean that termination can be stated as<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>
$$\forall i \in [0, N): m_i \text{ is passive} \land B = 0$$</p><p>In other words, the system is stable if all machines are passive and no messages are on their way (to wake up a machine).</p><p>It&rsquo;s clear we need to know $B$ to detect termination. If we knew how many messages had been sent and received by each machine, we can easily compute $B$. Thus, let&rsquo;s construct our first invariant, $P_0$, to help us keep track of $B$.</p><p>$$P_0: \quad B = \Sigma_{i = 0}^{N - 1}c_i$$</p><p>Intuitively, we want $c_i$ to be the net messages sent by machine $i$, and we enforce this by adding a rule to the system.</p><blockquote><p>Rule 0: Each machine maintains its own counter $c_i$, incrementing it by 1 when it sends a message and decrementing it by 1 when it receives a message<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>. It follows that we should initialize all $c_i$ to 0 when the machines first start.</p></blockquote><p>$P_0$ doesn&rsquo;t depend on $t$, so $m_0$ receiving the token after it has been sent around the ring doesn&rsquo;t help us determine anything. Consequently, let&rsquo;s say that the token has a value $q$ and add a condition $P_1$.</p><p>$$P_1: \quad \forall i \in (t, N): m_i \text{ is passive} \land \Sigma_{i = t + 1}^{N - 1}c_i = q$$</p><p>If $P_1$ is true, that means that all machines that have already handled the token are passive, and the sum of their counters $c_i$ is equal to the value of the token. The token being integer-valued and connected to the $c_i$ is critical to the termination detection algorithm as it encodes information about $B$, which is hard to know without an overall view of the system, into something that can be passed around<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup>.</p><p>Now, our invariant is $P_0 \land P_1$. If the invariant holds, when the token returns at $t = 0$,</p><p>$$
\begin{aligned}
& P_0 \land P_1 \land t = 0 \\
\implies & B = \Sigma_{i = 0}^{N - 1}c_i \land \forall i \in (0, N): m_i \text{ is passive} \land \Sigma_{i = 1}^{N - 1}c_i = q \\
\implies & B = c_0 + q \land \forall i \in (0, N): m_i \text{ is passive}
\end{aligned}
$$</p><p>That is, all machines other than $m_0$ are passive (plus the little equation, $c_0 + q = B$, that follows from some arithmetic).</p><p>Recall that all machines are passive and $B = 0$ when the system is stable. Thus, given the invariant, the system is stable when $t = 0$ if $m_0$ is passive (it&rsquo;s the only machine we aren&rsquo;t certain about the state of) and $c_0 + q = 0$.</p><hr><p>How do we maintain $P_1$? Observe that the probe starts with $t = N - 1, q = 0$. The boundary conditions mean that at this point, there are no terms in the $\forall$ and $\Sigma$ operations, so while we aren&rsquo;t making a statement on which machines are passive, we <em>are</em> stating that $q$ must be 0 since there&rsquo;s nothing being summed. That leads us to <code>Rule 1</code>.</p><blockquote><p>Rule 1: When the probe starts, $m_0$ sends the token with a value of 0 (i.e. $q = 0$) to $m_{N - 1}$.</p></blockquote><p>When a machine transmits the token, due to the invariant it must be making a statement that it is passive. It also must update the value of the token. Thus, we introduce <code>Rule 2</code>.</p><blockquote><p>Rule 2: A machine $m_{i + 1}$ <em>only</em> transmits the token to the next machine $m_i$ after $m_{i + 1}$ becomes passive, and the token&rsquo;s value is updated to $q = q + c_{i + 1}$.</p></blockquote><hr><p>When is $P_1$ false? Most directly, $P_1$ is false if, when the token is at index $t$, some machine $m_i$, $t &lt; i &lt; N$, is active <em>or</em> $\Sigma_{i = t + 1}^{N - 1}c_i \neq q$. Let $m_i$ be the first machine to cause a violation of $P_1$.</p><p>Suppose $m_i$ violates $P_1$ by becoming active. Recall that a machine only forwards the token when it becomes passive, so if $m_i$ is now active, it must have received a message.</p><p>Meanwhile, suppose $\Sigma_{j = t + 1}^{N - 1}c_j \neq q$. Since $m_i$ is the <em>first</em> machine to cause a violation of $P_1$, $\Sigma_{j = i + 1}^{N - 1}c_j = q_i$ (let $q_k$ be the value of the token when $m_k$ received it) must have been true for the whole period during which $m_i$ held the token. By <code>Rule 2</code>, $\Sigma_{j = i}^{N - 1} = q_{i - 1}$ must also be true when $m_i$ transmits the token, and remain true until the violation is caused by $m_i$. A violation can be caused by $m_i$ if $c_i$ changes. As $m_i$ is passive, $c_i$ can only change via receipt of a message.</p><p>We conclude that the only way for $m_i$ to cause a violation of $P_1$ is by receiving a message. In real world terms, this means that $m_i$ was woken up by a message that was either still in-transit or yet to be sent when it became passive. Further, in the instance <em>right before</em> the violation, there must be a message on its way to $m_i$. This is expressed by $B \geq 1$.</p><p>Since $P_0 \land P_1$ is true the moment before $P_1$ is violated, we have</p><p>$$
\begin{aligned}
1 \leq B = & \Sigma_{i = 0}^{N - 1}c_i \\
B = & \Sigma_{i = 0}^{t}c_i + \Sigma_{i = t + 1}^{N - 1}c_i \\
B = & \Sigma_{i = 0}^{t}c_i + q \\
\therefore 0 &lt; 1 &\leq \Sigma_{i = 0}^{t}c_i + q \\
\\
P_2: \quad \quad \quad & \Sigma_{i = 0}^{t}c_i + q > 0
\end{aligned}
$$</p><p>Observe that $P_2$ is true even if $m_i$, $t &lt; i &lt; N$, receives a message because no machine with $i > t$ is involved in the statement. So we can say either $P_1$ or $P_2$ is true, and our invariant becomes $P_0 \land (P_1 \lor P_2)$.</p><p>When the probe concludes at $t = 0$, $P_2$ evaluates as $c_0 + q > 0$. Recall that when the system is stable, we have $c_0 + q = 0$, so $P_2$ must be false when that occurs. Thus, the invariant returns to just $P_0 \land P_1$ when $c_0 + q = 0$, and we already know how to conclude termination when $P_0 \land P_1$. As a result, introducing $P_2$ does not make it any harder to conclude termination.</p><hr><p>It&rsquo;s getting gnarly now! Under $P_2$, $m_i$ where $0 \leq i \leq t$ is free to send as many messages as desired - doing so only increases $c_i$, so the invariant is maintained. However, if $c_i$ decreases due to $m_i$ receiving a message, we might falsify $P_2$! So, let&rsquo;s add a statement to the invariant to capture the receipt of a message by $m_i$.</p><p>$$
P_3: \quad \exists i \in [0, t]: \text{machine } i \text{ is black}
$$</p><p>We also add a corresponding <code>Rule 3</code>.</p><blockquote><p>Rule 3: When a machine receives a message, it changes its color to black.</p></blockquote><p>Fortunately, this still doesn&rsquo;t make it any harder to detect termination. Our invariant is now $P_0 \land (P_1 \lor P_2 \lor P_3)$, and we already know that $P_2$ is false at termination, so we just need to make sure that $P_3$ is also false at termination.</p><p>At $t = 0$, when we can try to determine termination, $m_0$ must be black to satisfy $P_3$. If $P_3$ is false, we can apply our previously derived techniques for detecting termination; thus, if $m_0$ is white when the token returns, we have a shot at detecting termination.</p><hr><p>What, you thought we were going to stop at $P_3$? Nope! If a black machine propagates the token, we are in danger of violating $P_3$ since that machine falls out of the set of machines referenced in $P_3$. This doesn&rsquo;t necessarily mean the full invariant is invalidated as other parts of it can be true, so let&rsquo;s construct a scenario where $P_1$ and $P_2$ are also false when a black machine propagates the token.</p><p>Let $m_t$, $t > 0$ be the last black machine. Suppose that machines $m_i$, $i &lt; t$ have $c_i = 0$ and are white. While $m_t$ holds the token, it sends a message to $m_x$, $x > t$ - this breaks $P_1$!</p><p>Then, $m_t$ passes the token to $m_{t - 1}$. Suddenly, $P_2$ is falsified as $\sum_{i = 0}^{t - 1}c_i = 0$. Meanwhile, no machines $0..t - 1$ received a message, so all machines within the set described in $P_3$ are white and $P_3$ is false too!</p><hr><p>Clearly, we have to introduce $P_4$ to rectify the situation. Let&rsquo;s color the token!</p><p>$$P_4: \quad \text{the token is black}$$</p><blockquote><p>Rule 4: If a black machine is to transmit the token, it colors the token black before sending it.</p></blockquote><p>If the token is white when it makes it back to $m_0$, then $P_4$ is false, and we have a chance at detecting termination.</p><p>At this point, we are done modifying the invariant! The color of the token never changes back to white from black, so it can never be made untrue at some later step.</p><p>Overall, we constructed the invariant as follows:</p><ol><li>Constructed $P_1$.</li><li>$P_1$ can be falsified by the receipt of a message by $m_i$, $t &lt; i &lt; N$, so we constructed $P_2$ which is true at least as early as the instant before $P_1$ becomes false.</li><li>$P_2$ can be falsified by receipt of a message by $m_i$, $0 \leq i \leq t$, so we constructed $P_3$, which becomes true the instant $m_i$ receives a message.</li><li>$P_3$ can be falsified by the last black machine transmitting the token, so we constructed $P_4$, which becomes true whenever any black machine transmits the token.</li><li>Once true, $P_4$ never becomes false.</li></ol><p>Thus, by construction our invariant holds for all states in the system.</p><hr><p>Let us summarize what we know so far. The invariant $P_0 \land (P_1 \lor P_2 \lor P_3 \lor P_4)$ is always true. $P_0$ is true by design, and we know how to detect termination when $P_0 \land P_1$. By the invariant, $P_1$ must be true if $P_2$, $P_3$, and $P_4$ are all false. Thus, we have a chance at detecting termination when the token returns at $t = 0$ if:</p><ol><li>$c_0 + q = 0 \implies \neg P_2$ (i.e. $P_2$ is false)</li><li>$m_0 \text{ is white} \implies \neg P_3$</li><li>$\text{The token is white} \implies \neg P_4$</li></ol><p>When only $P_1$ is true when the token returns, all machines $1..N-1$ are passive, so the system is totally passive if $m_0$ is also passive.</p><p>Thus, points 1-3 and $m_0$ being passive at $t = 0$ are the conditions for concluding that the system has reached stable state.</p><hr><p>What happens if any of the conditions are false? Well, we can&rsquo;t make a conclusive determination, so we run the probe again - what, you thought we could only probe once?</p><blockquote><p>Rule 5: $m_0$ initiates another probe after an unsuccessful probe.</p></blockquote><p>Running the probe again is insufficient though! If the token can&rsquo;t change back to white, the outcome of the next probe will be no different ($P_4$ will always be true). Further, even if the token color can change, if machine colors don&rsquo;t change, then either $m_0$ stays black or the token is turned back to black as it makes its way around the ring. Consequently, we need to be able to change colors for both the token and all machines.</p><p>While changing colors back to white, we must be careful to ensure the invariant $P_0 \land (P_1 \lor P_2 \lor P_3 \lor P_4)$ is maintained! Otherwise, all of our good work will have gone to waste.</p><p>Note that the invariant is true when the probe is first started. $P_0$ is always true thanks to <code>Rule 0</code>, and we established earlier that $P_1$ is trivially true when $m_0$ sends the token to $m_{N - 1}$. So, we can whiten $m_0$ and the token when initiating the probe again.</p><blockquote><p>Rule 6: At initiation of the probe, $m_0$ whitens itself and the token.</p></blockquote><p>Additionally, note that $P_3$ only makes a statement about machines whose index is $t$ or less. As a result, it&rsquo;s always safe to whiten a machine whose index exceeds $t$.</p><blockquote><p>Rule 7: After transmitting the token to $m_i$, $m_{i + 1}$ whitens itself.</p></blockquote><p>It follows that when no messages are in-flight ($B = 0$), no machines turn black anymore, all black machines whiten themselves eventually, and the token eventually stays white. When $B=0$ <em>and</em> all machines are passive, every $c_i$ becomes constant because no machine is able to send messages and there are no messages in transit that might decrease some $c_i$. When a probe is started during such a state, $P_1$ stays true throughout the probe. When the probe ends, $c_0 + q = B = 0$. Therefore, all conditions for detecting termination eventually become true after the system becomes passive!</p><p>Exhausted? That makes two of us!</p><hr><p>I started writing this post while I was reading EWD998, but I&rsquo;ve already completed the workshop and have yet to publish it üòÖ</p><p>So, I&rsquo;ll take this opportunity to note that the workshop was terrific! Many thanks and kudos to Markus for putting together such a great experience. We implemented the termination detection algorithm - you can see my spec <a href=https://github.com/lynshi/ewd998/blob/main/EWD998.tla>here</a> - and I learned a lot about TLA+! Hopefully I&rsquo;ll get a chance to write a spec for some of the systems I&rsquo;ve designed to catch all the edge cases I undoubtedly have missed.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Ackchyually, I read the <a href=https://raft.github.io/raft.pdf>Raft paper</a> when I first started working (technically still almost 3 years ago though!) and <a href=https://arxiv.org/pdf/2004.05074.pdf>Paxos vs Raft: Have we reached consensus on distributed consensus?</a> sometime last year. But they didn‚Äôt have any mathematical notation, so my brain didn‚Äôt really get fried and therefore it doesn&rsquo;t count.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Dijkstra uses the term <code>nr.i</code> to refer to machine <code>i</code>, but that doesn&rsquo;t look good and is even a little confusing in LaTeX.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>This concludes the easy part! If I were a student, I&rsquo;d be worried about plagiarism because I&rsquo;m almost quoting the paper verbatim so far. Thankfully, we don&rsquo;t have to be so rigorous here.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>&ldquo;Neither the algorithm nor its variations are the point of the note, which is about the derivation strategy, which worked again.&rdquo;&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>EWD998 references <a href=https://www.cs.utexas.edu/users/EWD/ewd08xx/EWD840.PDF>EWD840</a>, which solves a similar problem with the assumption of instantaneous message delivery. EWD840 feels a bit more accessible - maybe because I read (*cough* skimmed) it after EWD998, but it also seems to contain a bit more color on why certain steps are taken.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>Dijkstra uses $\underline{A}$, $\underline{S}$, and $\underline{E}$ for $\forall$ (for all), $\Sigma$ (sum), and $\exists$ (exists), respectively. I&rsquo;ll use the math symbols since they&rsquo;re more familiar to me. All ranges are over integers, so $[0, 5) = \{ 0, 1, 2, 3, 4 \}$.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>Dijkstra remarks that because the value of $B$ changes in a distributed fashion (i.e. based on the individual sending/receiving actions of each machine), our only option to compute $B$ is to try to compute it in a distributed fashion too. Sounds reasonable to me!&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p>This explains why Dijkstra&rsquo;s previous solution in EWD840 only uses a colored token. In that scenario, messages are delivered instantaneously, so we don&rsquo;t have to worry about keeping track of how many messages are in-flight. This also suggests that an integer-valued token (as well as formulation of the problem) was Shmuel Safra&rsquo;s key contribution.&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=http://lynshi.github.io/tags/distributed-systems/>Distributed systems</a></li><li><a href=http://lynshi.github.io/tags/tla+/>TLA+</a></li></ul><nav class=paginav><a class=next href=http://lynshi.github.io/posts/@shilyndon/purging-azure-cdn-with-github-actions-1c18e2adaf18/><span class=title>Next ¬ª</span><br><span>Purging Azure CDN With GitHub Actions</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Understanding EWD998: Shmuel Safra's version of termination detection on twitter" href="https://twitter.com/intent/tweet/?text=Understanding%20EWD998%3a%20Shmuel%20Safra%27s%20version%20of%20termination%20detection&url=http%3a%2f%2flynshi.github.io%2fposts%2funderstanding-ewd998%2f&hashtags=Distributedsystems%2cTLA%2b"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Understanding EWD998: Shmuel Safra's version of termination detection on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2flynshi.github.io%2fposts%2funderstanding-ewd998%2f&title=Understanding%20EWD998%3a%20Shmuel%20Safra%27s%20version%20of%20termination%20detection&summary=Understanding%20EWD998%3a%20Shmuel%20Safra%27s%20version%20of%20termination%20detection&source=http%3a%2f%2flynshi.github.io%2fposts%2funderstanding-ewd998%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Understanding EWD998: Shmuel Safra's version of termination detection on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flynshi.github.io%2fposts%2funderstanding-ewd998%2f&title=Understanding%20EWD998%3a%20Shmuel%20Safra%27s%20version%20of%20termination%20detection"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://lynshi.github.io/>Nibbles and Bytes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>